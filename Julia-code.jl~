# julia code main wrapper function

single_priors = csvread("priors_singles.csv")
matrix_priors = csvread("priors_matrix.csv")
data = csvread("datas.csv")

function  split_merge_sampler(datas,single_priors,matrix_priors,num_iters,thin)

a_0 = single_priors[1]
b_0 = single_priors[2]

k_0 = single_priors[3]
v_0 = single_priors[4]

mu_0::Float32 = single_priors[5]

lambda_0::Float32 =  matrix_priors

alpha::Float32 = 1

# initialize structures

(D, N) = size(datas)
max_class_id = N

k_0s=zeros(Float32,num_iters/thin)
K_plus = 1
class_id = zeros(Uint16,(N,num_iters))
class_ids = zeros(Uint16,(N,num_iters/thin))
K_record = zero(Uint16,(num_iters/thin,1))
alpha_record = zero(Float32,(num_iters/thin,1))

% seat the first customer at the first table
class_id[1,1] = 1

% precompute student-T posterior predictive distribution constants
pc_max_ind = 1e5
pc_gammaln_by_2 = 1:pc_max_ind
pc_gammaln_by_2 = lgamma(pc_gammaln_by_2/2)
pc_log_pi = log(pi)
pc_log = log(1:pc_max_ind)

means = zeros(Float32,(D,max_class_id))
sum_squares = zeros(Float32,(D,D,max_class_id))
inv_cov = zeros(Float32,(D,D,max_class_id))
log_det_cov = zeros(Float32,(max_class_id))
counts = zeros(Uint16,max_class_id,1)
counts[1] = 1

 p_under_prior_alone = zeros(N,1);

# sit first individual at first table
y = datas[:,1]
yyT = y*y'

(ldc,ic) = student_lp(pc_max_ind,pc_gammaln_by_2,pc_log_pi,pc_log,y,1,y,k_0,mu_0,v_0,lambda_0)

means[:,1] = y
sum_squares[:,:,1] = y * y'
counts[1] = 1
log_det_cov[1] = ldc
inv_cov[:,:,1] = ic

yyT = zeros(Float32,(D,D,N))

for i=1:N
  yyT[:,:,i]=datas[:,i]*datas[:,i]'
end  

## start MCMC ---- 
for iter=1:num_iters
    
# timer

    time_1_iter = toc()
    totaltime = disptime(totaltime,time_1_iter)
    tic()

# calculate P for each individual under prior alone
    p_under_prior_alone = p_for_1(lambda_0,mu_0,k_0,v_0,D,N,datas,p_under_prior_alone)

# run split-merge bit
    
    if iter>20
        (class_id[:,iter],K_plus,sums_squares,means,inv_cov,log_det_cov,counts) = split_merge(datas,class_id[:,iter-1],pc_max_ind,pc_gammaln_by_2,pc_log_pi,pc_log,N,k_0,mu_0,v_0,lambda_0,D,sums_squares,yyT,means,inv_cov,log_det_cov,counts,K_plus)
    end
    
# run gibbs bit

if iter.~=1  && sweep.<=20
        class_id[:,iter] = class_id[:,iter-1];
    end

    (class_id[:,iter],K_plus,sums_squares,means,inv_cov,log_det_cov,counts) = crp_gibbs(datas,iter,class_id,pc_max_ind,pc_gammaln_by_2,pc_log_pi,pc_log,N,k_0,mu_0,v_0,lambda_0,D,sums_squares,yyT,means,inv_cov,log_det_cov,counts,K_plus)

# update alpha

alpha = update_alpha(alpha,N,K_plus,a_0,b_0)

# update prior

(k_0,mu_0) = update_prior(D,K_plus,means,sum_squares,counts,mu_0,v_0,k_0,lambda_0)

# save parameter values

if mod(inter,thin)==0
        K_record[inter/thin] = K_plus;
        alpha_record[inter/thin] = alpha;
        k_0s[inter/thin]=k_0;
        class_ids[:,inter/thin]=class_id[:,iter];

end

end

return(class_ids,k_0s,K_record,alpha_record)

# write out simualtions

csv_write("source_ids.csv",class_ids)
csv_write("K_record.csv",K_record)
csv_write("gammas.csv",alpha_record)
csv_write("k_0s.csv",k_0s)

end









