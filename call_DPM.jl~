function call_DPM(bl,numiters,thin,wd)

# julia code main wrapper function

cd(wd)

load("DPM_sampler.jl")

single_priors = dlmread("single_priors.csv",",",Float64)
single_priors=single_priors[2:end,2]

matrix_priors = dlmread("matrix_priors.csv",",",Float64)
matrix_priors=matrix_priors[2:end,2:end]

datas =dlmread("datas.csv",",",Float64)
datas=datas[2:end,2:end]'

outs={}
np::Int = nprocs()
nit=int(np*numiters/thin);

class_ids=Array(Float64,(size(datas,1),nit))
k_0s=Array(Float64,nit)
K_record=Array(Int8,nit)
alpha_record=Array(Float64,nit)

if bl.==1
   baseline = csvread("baseline.csv")
   @everywhere load("DPM_sampler_fix.jl")
   for n=1:np
       push(outs,@spawn DPM_sampler_fix(datas,baseline_single_priors,matrix_priors,numiters,thin))
 
   end
else
   @everywhere load("DPM_sampler.jl")
   for n=1:np
    
       push(outs,@spawn DPM_sampler(datas,single_priors,matrix_priors,numiters,thin))

   end
end

#nit=int(numiters/thin);
n::Int = 0
 while length(outs)>0
 n=n+1
     res = fetch(pop(outs))
     class_ids[((n-1)*numiters/thin+1):((n-1)*numiters/thin+numiters/thin),:] = res[1]
     k_0s[((n-1)*numiters/thin+1):((n-1)*numiters/thin+numiters/thin)] = res[2]
     K_record[((n-1)*numiters/thin+1):((n-1)*numiters/thin+numiters/thin)] =res[3]
     alpha_record[((n-1)*numiters/thin+1):((n-1)*numiters/thin+numiters/thin)] = res[4]
end

# write out simualtions

csv_write("source_ids.csv",class_ids)
csv_write("K_record.csv",K_record)
csv_write("gammas.csv",alpha_record)
csv_write("k_0s.csv",k_0s)

end

outs={}
for n=1:2
   push(outs, @spawn rand2(2,2))
   end
   
 while length(outs)>0
 res = fetch(pop(outs))
 end
   
